---
totail:
icon: book
date: 2023-10-01
category:
  - 编程
tag:
  - Redis
---

# Redis数据结构及使用场景
<!-- more -->
## String（字符串）
### 内部实现：
String 类型的底层的数据结构实现主要是 **int** 和 **SDS**（简单动态字符串）。
- SDS 和我们认识的 C 字符串不太一样，之所以没有使用 C 语言的字符串表示，因为 SDS 相比于 C 的原生字符串：

- SDS 不仅可以保存文本数据，还可以保存二进制数据。因为 SDS 使用 len 属性的值而不是空字符来判断字符串是否结束，并且 SDS 的所有 API 都会以处理二进制的方式来处理 SDS 存放在 buf[] 数组里的数据。所以 SDS 不光能存放文本数据，而且能保存图片、音频、视频、压缩文件这样的二进制数据。

- SDS 获取字符串长度的时间复杂度是 O(1)。因为 C 语言的字符串并不记录自身长度，所以获取长度的复杂度为 O(n)；而 SDS 结构里用 len 属性记录了字符串长度，所以复杂度为 O(1)。

- Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出。因为 SDS 在拼接字符串之前会检查 SDS 空间是否满足要求，如果空间不够会自动扩容，所以不会导致缓冲区溢出的问题。
字符串对象的内部编码（encoding）有 3 种 ：int、raw和 embstr。
### 使用场景

 1.  **缓存对象**
	-  直接缓存整个对象的 JSON，命令例子： SET user:1 '{"name":"xiaolin", "age":18}'。
	-  采用将 key 进行分离为 user:ID:属性，采用 MSET 存储，用 MGET 获取各属性值，命令例子： MSET user:1:name xiaolin user:1:age 18 user:2:name xiaomei user:2:age 20。
2. **分布式锁**
SET 命令有个 NX 参数可以实现「key不存在才插入」，可以用它来实现分布式锁：
	- 如果 key 不存在，则显示插入成功，可以用来表示加锁成功；
	- 如果 key 存在，则会显示插入失败，可以用来表示加锁失败。
	
 ## List（列表）
### 内部实现
List 数据类型底层数据结构由 quicklist 实现
### 使用场景
1. 消息队列
	消息队列在存取消息时，必须要满足三个需求，分别是消息保序、处理重复的消息和保证消息可靠性。
	Redis 的 List 和 Stream 两种数据类型，就可以满足消息队列的这三个需求。我们先来了解下基于 List 的消息队列实现方法，后面在介绍 Stream 数据类型时候，在详细说说 Stream。

 ## Hash（哈希）
 ### 内部实现
Hash 类型的底层数据结构是由 listpack 或哈希表实现的：
如果哈希类型元素个数小于 512 个（默认值，可由 hash-max-ziplist-entries 配置），所有值小于 64 字节（默认值，可由 hash-max-ziplist-value 配置）的话，Redis 会使用listpack作为 Hash 类型的底层数据结构；
如果哈希类型元素不满足上面条件，Redis 会使用哈希表作为 Hash 类型的 底层数据结构。
### 使用场景
1. 缓存对象
	Hash 类型的 （key，field， value） 的结构与对象的（对象id， 属性， 值）的结构相似，也可以用来存储对象。
2. 购物车
	以用户 id 为 key，商品 id 为 field，商品数量为 value，恰好构成了购物车的3个要素

 ## Set（集合）
 ### 内部实现
Set 类型的底层数据结构是由哈希表或整数集合实现的：
- 如果集合中的元素都是整数且元素个数小于 512 （默认值，set-maxintset-entries配置）个，Redis 会使用整数集合作为 Set 类型的底层数据结构；
- 如果集合中的元素不满足上面条件，则 Redis 使用哈希表作为 Set 类型的底层数据结构。

 ### 使用场景
 集合的主要几个特性，无序、不可重复、支持并交差等操作。
 1. 点赞
	Set 类型可以保证一个用户只能点一个赞。
2. 共同关注
	Set 类型支持交集运算，所以可以用来计算共同关注的好友、公众号等。
3. 抽奖活动
	存储某活动中中奖的用户名 ，Set 类型因为有去重功能，可以保证同一个用户不会中奖两次。

 ## Zset（有序集合）
 ### 内部实现
  Zset 类型的底层数据结构是由listpack或跳表实现的：
- 如果有序集合的元素个数小于 128 个，并且每个元素的值小于 64 字节时，Redis 会使用listpack作为 Zset 类型的底层数据结构；
- 如果有序集合的元素不满足上面的条件，Redis 会使用跳表作为 Zset 类型的底层数据结构；

 ### 使用场景
 1. 排行榜
	有序集合比较典型的使用场景就是排行榜。
	可以根据想要排序的字段以及辅助字段组成权重分数  然后根据分数进行排序查询。

## BitMap
### 内部实现
- Bitmap 本身是用 String 类型作为底层数据结构实现的一种统计二值状态的数据类型。
- String 类型是会保存为二进制的字节数组，所以，Redis 就把字节数组的每个 bit 位利用起来，用来表示一个元素的二值状态，你可以把 Bitmap 看作是一个 bit 数组。
### 使用场景
1. 签到统计
	在签到打卡的场景中，我们只用记录签到（1）或未签到（0），所以它就是非常典型的二值状态。
	签到统计时，每个用户一天的签到用 1 个 bit 位就能表示，一个月（假设是 31 天）的签到情况用 31 个 bit 位就可以，而一年的签到也只需要用 365 个 bit 位，根本不用太复杂的集合类型。
2.  判断用户登陆态
	Bitmap 提供了 GETBIT、SETBIT 操作，通过一个偏移值 offset 对 bit 数组的 offset 位置的 bit 位进行读写操作，需要注意的是 offset 从 0 开始。

## HyperLogLog
Redis HyperLogLog 是 Redis 2.8.9 版本新增的数据类型，是一种用于「统计基数」的数据集合类型，基数统计就是指统计一个集合中不重复的元素个数。但要注意，HyperLogLog 是统计规则是基于概率完成的，不是非常准确，标准误算率是 0.81%。
所以，简单来说 HyperLogLog 提供不精确的去重计数。
### 内部实现
	不会
### 使用场景
1. 百万级网页 UV 计数
	Redis HyperLogLog 优势在于只需要花费 12 KB 内存，就可以计算接近 2^64 个元素的基数，和元素越多就越耗费内存的 Set 和 Hash 类型相比，HyperLogLog 就非常节省空间。

## GEO
Redis GEO 是 Redis 3.2 版本新增的数据类型，主要用于存储地理位置信息，并对存储的信息进行操作。
### 内部实现
	GEO 本身并没有设计新的底层数据结构，而是直接使用了 Sorted Set 集合类型。

### 使用场景

## Stream
Redis Stream 是 Redis 5.0 版本新增加的数据类型，Redis 专门为消息队列设计的数据类型。

### 使用场景
1. 消息队列
	- 生产者通过 XADD 命令插入一条消息：插入成功后会返回全局唯一的 ID
	- 消费者通过 XREAD 命令从消息队列中读取消息时，可以指定一个消息 ID，并从这个消息 ID 的下一条消息开始进行读取（注意是输入消息 ID 的下一条信息开始读取，不是查询输入ID的消息）。
	- 如果想要实现阻塞读（当没有数据时，阻塞住），可以调用 XRAED 时设定 BLOCK 配置项，实现类似于 BRPOP 的阻塞读取操作。
	- Stream 可以以使用 XGROUP 创建消费组，创建消费组之后，Stream 可以使用 XREADGROUP 命令让消费组内的消费者读取消息。
	- 消息队列中的消息一旦被消费组里的一个消费者读取了，就不能再被该消费组内的其他消费者读取了，即同一个消费组里的消费者不能消费同一条消息。但是，不同消费组的消费者可以消费同一条消息（但是有前提条件，创建消息组的时候，不同消费组指定了相同位置开始读取消息）。
	- 如果消费者没有成功处理消息，它就不会给 Streams 发送 XACK 命令，消息仍然会留存。此时，消费者可以在重启后，用 XPENDING 命令查看已读取、但尚未确认处理完成的消息。