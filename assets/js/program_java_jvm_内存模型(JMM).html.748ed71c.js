"use strict";(self.webpackChunkxwblog=self.webpackChunkxwblog||[]).push([[642],{66262:(t,l)=>{l.A=(t,l)=>{const i=t.__vccOpts||t;for(const[t,e]of l)i[t]=e;return i}},41692:(t,l,i)=>{i.r(l),i.d(l,{comp:()=>n,data:()=>p});var e=i(20641);const r=(0,e.Lk)("h1",{id:"内存模型-jmm",tabindex:"-1"},[(0,e.Lk)("a",{class:"header-anchor",href:"#内存模型-jmm"},[(0,e.Lk)("span",null,"内存模型（JMM）")])],-1),o=(0,e.Lk)("p",null,"简单的说，JMM 定义了一套在多线程读写共享数据时（成员变量、数组）时，对数据的可见性、有序 性、和原子性的规则和保障",-1),a=(0,e.Fv)("<ol><li><p>原子性</p><ul><li>在Java 的内存模型如下，完成静态变量的自增，自减需要在主存和线程内存中进行数据交换</li><li>通过synchronized 可以解决原子性</li></ul></li><li><p>可见性</p><ul><li>JIT 编译器会将 run 的值缓存至自己工作内存中的高速缓存中，减少对主存中 run 的访问，提高效率 mian线程修改run的值 其他线程读取的还是告诉缓存中的值</li><li>通过volatile（易变关键字） 它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，<strong>线程操作 volatile 变量都是直接操作主存</strong></li><li>synchronized 语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性。但缺点是synchronized是属于重量级操作，性能相对更低</li></ul></li><li><p>有序性</p><ul><li><strong>指令重排</strong>，是 JIT 编译器在运行时的一些优化，cpu交替运行时 有些耗时的指令经过分析 执行顺序可能存在变动 指令重排会在多线程的情况下出现问题</li><li>可以使用volatile 修饰即可，可以禁用指令重排</li></ul></li><li><p><strong>happens-before</strong></p><ul><li><p>happens-before 规定了哪些写操作对其它线程的读操作可见，它是可见性与有序性的一套规则总结， 抛开以下 happens-before 规则，JMM 并不能保证一个线程对共享变量的写，对于其它线程对该共享变量的读可见</p><ul><li><p>线程解锁 m 之前对变量的写，对于接下来对 m 加锁的其它线程对该变量的读可见</p></li><li><p>线程对 volatile 变量的写，对接下来其它线程对该变量的读可见</p></li><li><p>线程 start 前对变量的写，对该线程开始后对该变量的读可见</p></li><li><p>线程结束前对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 t1.isAlive() t1.join()等待它结束）</p></li><li><p>线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见（通 过t2.interrupted 或 t2.isInterrupted）</p></li><li><p>对变量默认值（0，false，null）的写，对其它线程对该变量的读可见</p></li><li><p>具有传递性，如果 x hb-&gt; y 并且 y hb-&gt; z 那么有 x hb-&gt; z</p><blockquote><p>变量都是指成员变量或静态成员变量</p></blockquote></li></ul></li></ul></li><li><p>CAS与原子类</p><ol><li>CAS 即 Compare and Swap ，它体现的一种乐观锁的思想 <ol><li>获取共享变量时，为了保证该变量的可见性，需要使用 volatile 修饰。结合 CAS 和 volatile 可以实现无锁并发，适用于竞争不激烈、多核 CPU 的场景下。 <ul><li>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一</li><li>但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响</li></ul></li><li>CAS 底层依赖于一个 Unsafe 类来直接调用操作系统底层的 CAS 指令</li></ol></li><li><strong>乐观锁与悲观锁</strong><ul><li>CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系， 我吃亏点再重试呗。</li><li>synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁 你们都别想改，我改完了解开锁，你们才有机会。</li></ul></li><li>原子操作类 <ul><li>juc（java.util.concurrent）中提供了原子操作类，可以提供线程安全的操作，例如：AtomicInteger、 AtomicBoolean等，它们底层就是采用 CAS 技术 + volatile 来实现的。</li></ul></li><li><strong>synchronized优化</strong></li></ol><p>Java HotSpot 虚拟机中，每个对象都有对象头（包括 class 指针和 Mark Word）。Mark Word 平时存 储这个对象的 哈希码 、 分代年龄 ，当加锁时，这些信息就根据情况被替换为 标记位 、 线程锁记录指 针 、 重量级锁指针 、 线程ID 等内容</p><ol><li><p><strong>轻量级锁</strong></p><ul><li>如果一个对象虽然有多线程访问，但多线程访问的时间是错开的（也就是没有竞争），那么可以使用轻 量级锁来优化。</li><li>每个线程都的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的 Mark Word</li></ul></li><li><p><strong>膨胀锁</strong></p><ul><li>如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁。</li></ul><table><thead><tr><th>线程1</th><th>对象 Mark</th><th>线程2</th></tr></thead><tbody><tr><td>访问同步块，把 Mark 复制到线程 1 的锁记录</td><td>01（无锁）</td><td></td></tr><tr><td>CAS 修改 Mark 为线程 1 锁记录地址</td><td>01（无锁）</td><td></td></tr><tr><td>成功（加锁）</td><td>00（轻量锁）线程 1 锁 记录地址</td><td></td></tr><tr><td>执行同步块</td><td>00（轻量锁）线程 1 锁 记录地址</td><td>访问同步块，把 Mark 复制 到线程 2</td></tr><tr><td></td><td>00（轻量锁）线程 1 锁 记录地址</td><td>CAS 修改 Mark 为线程 2 锁 记录地址</td></tr><tr><td></td><td>00（轻量锁）线程 1 锁 记录地址</td><td>失败（发现别人已经占了锁）</td></tr><tr><td></td><td>10（重量锁）重量锁指指针</td><td>CAS 修改 Mark 为重量锁</td></tr><tr><td>失败（解锁）</td><td>10（重量锁）重量锁指指针</td><td>阻塞</td></tr><tr><td>释放重量锁，唤起阻塞线程竞争</td><td>01（无锁）</td><td>阻塞</td></tr><tr><td></td><td>10（重量锁）</td><td>成功（加锁）</td></tr></tbody></table></li><li><p><strong>重量锁</strong></p><ul><li>重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退 出了同步块，释放了锁），这时当前线程就可以避免阻塞。</li><li>在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能 性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。</li></ul><blockquote><p>自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。 好比等红灯时汽车是不是熄火，不熄火相当于自旋（等待时间短了划算），熄火了相当于阻塞（等 待时间长了划算） Java 7 之后不能控制是否开启自旋功能</p></blockquote></li><li><p><strong>偏向锁</strong></p><ul><li>轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS 操作。Java 6 中引入了偏向锁 来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS.</li><li>弊端 <ol><li>撤销偏向需要将持锁线程升级为轻量级锁，这个过程中所有线程需要暂停（STW）</li><li>访问对象的 hashCode 也会撤销偏向锁</li><li>如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，</li><li>重偏向会重置对象的 Thread ID</li><li>撤销偏向和重偏向都是批量进行的，以类为单位</li><li>如果撤销偏向到达某个阈值，整个类的所有对象都会变为不可偏向的</li><li>可以主动使用 -XX:-UseBiasedLocking 禁用偏向锁</li></ol></li></ul></li></ol></li></ol>",1),d={},n=(0,i(66262).A)(d,[["render",function(t,l){return(0,e.uX)(),(0,e.CE)("div",null,[r,o,(0,e.Q3)(" more "),a])}]]),p=JSON.parse('{"path":"/program/java/jvm/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B(JMM).html","title":"内存模型（JMM）","lang":"zh-CN","frontmatter":{"icon":"dianjikai","date":"2023-10-01T00:00:00.000Z","category":["编程"],"tag":["Java","JVM"],"description":"简单的说，JMM 定义了一套在多线程读写共享数据时（成员变量、数组）时，对数据的可见性、有序 性、和原子性的规则和保障","head":[["meta",{"property":"og:url","content":"https://github.com/DUDU-dudu-DUDU/xwblog/xwblog/program/java/jvm/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B(JMM).html"}],["meta",{"property":"og:site_name","content":"小吴 Blog"}],["meta",{"property":"og:title","content":"内存模型（JMM）"}],["meta",{"property":"og:description","content":"简单的说，JMM 定义了一套在多线程读写共享数据时（成员变量、数组）时，对数据的可见性、有序 性、和原子性的规则和保障"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-25T12:17:01.000Z"}],["meta",{"property":"article:author","content":"xiaowu"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:tag","content":"JVM"}],["meta",{"property":"article:published_time","content":"2023-10-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-02-25T12:17:01.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"内存模型（JMM）\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-10-01T00:00:00.000Z\\",\\"dateModified\\":\\"2025-02-25T12:17:01.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"xiaowu\\",\\"url\\":\\"https://dudu-dudu-dudu.github.io/xwblog/zh/\\"}]}"]]},"headers":[],"git":{"createdTime":1740485821000,"updatedTime":1740485821000,"contributors":[{"name":"DUDU","email":"930824238@qq.com","commits":1}]},"readingTime":{"minutes":6.44,"words":1933},"filePathRelative":"program/java/jvm/内存模型(JMM).md","localizedDate":"2023年10月1日","excerpt":"\\n<p>简单的说，JMM 定义了一套在多线程读写共享数据时（成员变量、数组）时，对数据的可见性、有序 性、和原子性的规则和保障</p>\\n","autoDesc":true}')}}]);