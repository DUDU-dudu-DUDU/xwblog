---
icon: dianjikai
date: 2023-10-01
category:
  - 编程
tag:
  - Java
  - JVM
---
# 内存模型（JMM）


简单的说，JMM 定义了一套在多线程读写共享数据时（成员变量、数组）时，对数据的可见性、有序 性、和原子性的规则和保障
<!-- more -->
1. 原子性

   - 在Java 的内存模型如下，完成静态变量的自增，自减需要在主存和线程内存中进行数据交换
   - 通过synchronized 可以解决原子性

2. 可见性

   - JIT 编译器会将 run 的值缓存至自己工作内存中的高速缓存中，减少对主存中 run 的访问，提高效率 mian线程修改run的值  其他线程读取的还是告诉缓存中的值
   - 通过volatile（易变关键字） 它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，**线程操作 volatile 变量都是直接操作主存**
   - synchronized 语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性。但缺点是synchronized是属于重量级操作，性能相对更低

3. 有序性

   - **指令重排**，是 JIT 编译器在运行时的一些优化，cpu交替运行时 有些耗时的指令经过分析 执行顺序可能存在变动  指令重排会在多线程的情况下出现问题
   - 可以使用volatile 修饰即可，可以禁用指令重排

4. **happens-before**

   - happens-before 规定了哪些写操作对其它线程的读操作可见，它是可见性与有序性的一套规则总结， 抛开以下 happens-before 规则，JMM 并不能保证一个线程对共享变量的写，对于其它线程对该共享变量的读可见

     - 线程解锁 m 之前对变量的写，对于接下来对 m 加锁的其它线程对该变量的读可见

     - 线程对 volatile 变量的写，对接下来其它线程对该变量的读可见

     - 线程 start 前对变量的写，对该线程开始后对该变量的读可见

     - 线程结束前对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 t1.isAlive() t1.join()等待它结束）

     - 线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见（通 过t2.interrupted 或 t2.isInterrupted）

     - 对变量默认值（0，false，null）的写，对其它线程对该变量的读可见 

     - 具有传递性，如果 x hb-> y 并且 y hb-> z 那么有 x hb-> z

       > 变量都是指成员变量或静态成员变量



5. CAS与原子类

   1. CAS 即 Compare and Swap ，它体现的一种乐观锁的思想
      1. 获取共享变量时，为了保证该变量的可见性，需要使用 volatile 修饰。结合 CAS 和 volatile 可以实现无锁并发，适用于竞争不激烈、多核 CPU 的场景下。 
         - 因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一 
         - 但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响 
      2. CAS 底层依赖于一个 Unsafe 类来直接调用操作系统底层的 CAS 指令
   2. **乐观锁与悲观锁**
      - CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系， 我吃亏点再重试呗。 
      - synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁 你们都别想改，我改完了解开锁，你们才有机会。
   3. 原子操作类
      - juc（java.util.concurrent）中提供了原子操作类，可以提供线程安全的操作，例如：AtomicInteger、 AtomicBoolean等，它们底层就是采用 CAS 技术 + volatile 来实现的。
   4. **synchronized优化**

   Java HotSpot 虚拟机中，每个对象都有对象头（包括 class 指针和 Mark Word）。Mark Word 平时存 储这个对象的 哈希码 、 分代年龄 ，当加锁时，这些信息就根据情况被替换为 标记位 、 线程锁记录指 针 、 重量级锁指针 、 线程ID 等内容

   1. **轻量级锁**  

      - 如果一个对象虽然有多线程访问，但多线程访问的时间是错开的（也就是没有竞争），那么可以使用轻 量级锁来优化。
      - 每个线程都的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的 Mark Word

   2. **膨胀锁**

      - 如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁。

      | 线程1                                     | 对象 Mark                      | 线程2                              |
      | ----------------------------------------- | ------------------------------ | ---------------------------------- |
      | 访问同步块，把 Mark 复制到线程 1 的锁记录 | 01（无锁）                     |                                    |
      | CAS 修改 Mark 为线程 1 锁记录地址         | 01（无锁）                     |                                    |
      | 成功（加锁）                              | 00（轻量锁）线程 1 锁 记录地址 |                                    |
      | 执行同步块                                | 00（轻量锁）线程 1 锁 记录地址 | 访问同步块，把 Mark 复制 到线程 2  |
      |                                           | 00（轻量锁）线程 1 锁 记录地址 | CAS 修改 Mark 为线程 2 锁 记录地址 |
      |                                           | 00（轻量锁）线程 1 锁 记录地址 | 失败（发现别人已经占了锁）         |
      |                                           | 10（重量锁）重量锁指指针       | CAS 修改 Mark 为重量锁             |
      | 失败（解锁）                              | 10（重量锁）重量锁指指针       | 阻塞                               |
      | 释放重量锁，唤起阻塞线程竞争              | 01（无锁）                     | 阻塞                               |
      |                                           | 10（重量锁）                   | 成功（加锁）                       |

   3. **重量锁**

      - 重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退 出了同步块，释放了锁），这时当前线程就可以避免阻塞。 
      - 在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能 性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。

      > 自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。 好比等红灯时汽车是不是熄火，不熄火相当于自旋（等待时间短了划算），熄火了相当于阻塞（等 待时间长了划算） Java 7 之后不能控制是否开启自旋功能

   4. **偏向锁**

      - 轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS 操作。Java 6 中引入了偏向锁 来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS.
      - 弊端
        1. 撤销偏向需要将持锁线程升级为轻量级锁，这个过程中所有线程需要暂停（STW） 
        2. 访问对象的 hashCode 也会撤销偏向锁 
        3. 如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2， 
        4. 重偏向会重置对象的 Thread ID 
        5. 撤销偏向和重偏向都是批量进行的，以类为单位 
        6. 如果撤销偏向到达某个阈值，整个类的所有对象都会变为不可偏向的 
        7. 可以主动使用 -XX:-UseBiasedLocking 禁用偏向锁

   