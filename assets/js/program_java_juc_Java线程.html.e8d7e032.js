"use strict";(self.webpackChunkxwblog=self.webpackChunkxwblog||[]).push([[5261],{6262:(t,e)=>{e.A=(t,e)=>{const l=t.__vccOpts||t;for(const[t,o]of e)l[t]=o;return l}},2749:(t,e,l)=>{l.r(e),l.d(e,{comp:()=>s,data:()=>p});var o=l(641);const i=l.p+"assets/img/1741003381141.6d51a9f2.png",d=l.p+"assets/img/1741003705353.0f5399d8.png",r=(0,o.Lk)("h1",{id:"java线程",tabindex:"-1"},[(0,o.Lk)("a",{class:"header-anchor",href:"#java线程"},[(0,o.Lk)("span",null,"Java线程")])],-1),n=(0,o.Lk)("p",null,"Java线程的基础了解、方法，五种状态六种状态的深度解剖...",-1),a=(0,o.Fv)('<h2 id="java线程-1" tabindex="-1"><a class="header-anchor" href="#java线程-1"><span>Java线程</span></a></h2><h2 id="查看线程方法" tabindex="-1"><a class="header-anchor" href="#查看线程方法"><span>查看线程方法</span></a></h2><ul><li>windows <ul><li>tasklist 查看进程</li><li>taskkill 杀死进程</li></ul></li><li>linux <ul><li>ps -fe 查看所有进程</li><li>ps -fT -p (PID) 查看某个进程（PID）的所有线程 <ul><li>kill 杀死进程</li></ul></li><li>top 按大写 H 切换是否显示线程</li><li>top -H -p (PID) 查看某个进程（PID）的所有线程</li></ul></li><li>java <ul><li>jps 命令查看所有 Java 进程</li><li>jstack (PID) 查看某个 Java 进程（PID）的所有线程状态</li><li>jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）</li></ul></li></ul><h2 id="线程运行原理" tabindex="-1"><a class="header-anchor" href="#线程运行原理"><span>线程运行原理</span></a></h2><ul><li><p>栈与栈帧</p><ul><li><p>我们都知道 JVM 中由堆、栈、方法区所组成，其中栈内存是给谁用的呢？其实就是线程，每个线程启动后，虚拟 机就会为其分配一块栈内存。</p><blockquote><p>每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存</p><p>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</p></blockquote></li></ul></li><li><p>线程上下文切换</p><p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码</p><ul><li>线程的 cpu 时间片用完</li><li>垃圾回收</li><li>有更高优先级的线程需要运行</li><li>线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法</li></ul><p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念 就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的</p><blockquote><p>状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</p><p>Context Switch 频繁发生会影响性能</p></blockquote></li></ul><h2 id="常见方法" tabindex="-1"><a class="header-anchor" href="#常见方法"><span>常见方法</span></a></h2><table><thead><tr><th><strong>方法名</strong></th><th>功能说明</th><th>注意</th></tr></thead><tbody><tr><td>start()</td><td>启动一个新线程，在新的线程运行 run 方法中的代码</td><td>start 方法只是让线程进入就绪，里面代码不一定立刻运行（CPU 的时间片还没分给它）。每个线程对象的start方法只能调用一次，如果调用了多次会出现IllegalThreadStateException</td></tr><tr><td>run()</td><td>新线程启动后会调用的方法</td><td>如果在构造 Thread 对象时传递了 Runnable 参数，则线程启动后会调用 Runnable 中的 run 方法，否则默认不执行任何操作。但可以创建 Thread 的子类对象，来覆盖默认行为</td></tr><tr><td>join()</td><td>等待线程运行结束</td><td></td></tr><tr><td>join(long n)</td><td>等待线程运行结束,最多等待 n 毫秒</td><td></td></tr><tr><td>getId()</td><td>获取线程长整型的 id</td><td>id唯一</td></tr><tr><td>getName()</td><td>获取线程名</td><td></td></tr><tr><td>setName(String)</td><td>修改线程名</td><td></td></tr><tr><td>getPriority()</td><td>获取线程优先级</td><td></td></tr><tr><td>setPriority(int)</td><td>修改线程优先级</td><td>java中规定线程优先级是1~10 的整数，较大的优先级能提高该线程被 CPU 调度的机率</td></tr><tr><td>getState(）</td><td>获取线程状态</td><td>Java 中线程状态是用 6 个 enum 表示，分别为：NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED</td></tr><tr><td>isInterrupted()</td><td>判断是否被打 断</td><td>不会清除 打断标记</td></tr><tr><td>isAlive()</td><td>线程是否存活（还没有运行完毕）</td><td></td></tr><tr><td>interrupt()</td><td>打断线程</td><td>如果被打断线程正在 sleep，wait，join 会导致被打断的线程抛出 InterruptedException，并清除 打断标记 ；如果打断的正在运行的线程，则会设置 打断标记 ；park 的线程被打断，也会设置打断标记</td></tr><tr><td>interrupted()</td><td>（static）判断当前线程是否被打断</td><td>会清除 打断标记</td></tr><tr><td>currentThread()</td><td>（static）获取当前正在执行的线程</td><td></td></tr><tr><td>sleep(long n)</td><td>（static）让当前执行的线程休眠n毫秒，休眠时让出 cpu 的时间片给其它线程</td><td></td></tr><tr><td>yield()</td><td>（static）提示线程调度器让出当前线程对CPU的使用</td><td>主要是为了测试和调试</td></tr></tbody></table><h3 id="start-与-run" tabindex="-1"><a class="header-anchor" href="#start-与-run"><span>start 与 run</span></a></h3><ul><li>直接调用 run 是在主线程中执行了 run，没有启动新的线程</li><li>使用 start 是启动新的线程，通过新的线程间接执行 run 中的代码</li></ul><h3 id="sleep与-yield" tabindex="-1"><a class="header-anchor" href="#sleep与-yield"><span>sleep与 yield</span></a></h3><ul><li><strong>sleep</strong><ul><li>调用 sleep 会让当前线程从 <em>Running</em> 进入 <em>Timed Waiting</em> 状态（阻塞）</li><li>其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException</li><li>睡眠结束后的线程未必会立刻得到执行</li><li>建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性</li></ul></li><li><strong>yield</strong><ul><li>调用 yield 会让当前线程从 <em>Running</em> 进入 <em>Runnable</em> 就绪状态，然后调度执行其它线程</li><li>具体的实现依赖于操作系统的任务调度器</li></ul></li><li><strong>interrupt方法</strong><ul><li>打断sleep，wait，join的线程，这几个方法都会让线程进入阻塞状态</li><li>打断 sleep 的线程, 会清空打断状态</li><li>打断正常运行的线程, 不会清空打断状态</li><li>打断 park 线程, 不会清空打断状态 如果打断标记已经是 true, 则 park 会失效</li></ul></li></ul><p>主线程与守护线程</p><p>Java 进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其它非守</p><p>护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。使用thread.setDaemon(true);可以设置守护线程</p><blockquote><p>垃圾回收器线程就是一种守护线程</p><p>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等 待它们处理完当前请求</p></blockquote><h2 id="五种状态与六种状态" tabindex="-1"><a class="header-anchor" href="#五种状态与六种状态"><span>五种状态与六种状态</span></a></h2><h3 id="五种状态" tabindex="-1"><a class="header-anchor" href="#五种状态"><span>五种状态</span></a></h3><figure><img src="'+i+'" alt="1741003381141" tabindex="0" loading="lazy"><figcaption>1741003381141</figcaption></figure><ol><li><p>【初始状态】仅是在语言层面创建了线程对象，还未与操作系统线程关联</p></li><li><p>【可运行状态】（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由 CPU 调度执行</p></li><li><p>【运行状态】指获取了 CPU 时间片运行中的状态</p><ul><li>当 CPU 时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换</li></ul></li><li><p>【阻塞状态】</p><ul><li>如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入【阻塞状态】</li><li>等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】</li><li>与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑调度它们</li></ul></li><li><p>【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</p></li></ol><h3 id="六种状态详解" tabindex="-1"><a class="header-anchor" href="#六种状态详解"><span>六种状态详解</span></a></h3><figure><img src="'+d+'" alt="1741003705353" tabindex="0" loading="lazy"><figcaption>1741003705353</figcaption></figure><ol><li><strong>NEW</strong> 线程刚被创建，但是还没有调用 start() 方法</li><li><strong>RUNNABLE</strong> 当调用了 start() 方法之后，注意，Java API 层面的 RUNNABLE 状态涵盖了 <strong>操作系统</strong> 层面的 【可运行状态】、【运行状态】和【阻塞状态】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为是可运行）</li><li><strong>BLOCKED</strong> ， <strong>WAITING</strong> ， <strong>TIMED_WAITING</strong> 都是 Java API 层面对【阻塞状态】的细分，后面会在状态转换一节详述</li><li><strong>TERMINATED</strong> 当线程代码运行结束</li></ol><p>假设有线程 <code>Thread t</code></p><p>情况 1 <code>NEW --&gt; RUNNABLE</code></p><ul><li>当调用 <code>t.start()</code> 方法时，由 NEW --&gt; RUNNABLE</li></ul><p>情况 2 <code>RUNNABLE &lt;--&gt; WAITING</code></p><p><strong>t 线程</strong>用 <code>synchronized(obj)</code> 获取了对象锁后</p><ul><li>调用 <code>obj.wait()</code> 方法时，<strong>t 线程</strong>从 <code>RUNNABLE --&gt; WAITING</code></li><li>调用 <code>obj.notify()</code> ， <code>obj.notifyAll()</code> ， <code>t.interrupt()</code> 时 <ul><li>竞争锁成功，<strong>t 线程</strong>从 <code>WAITING --&gt; RUNNABLE</code></li><li>竞争锁失败，<strong>t 线程</strong>从 <code>WAITING --&gt; BLOCKED</code></li></ul></li></ul><p>情况 3 <code>RUNNABLE &lt;--&gt; WAITING</code></p><ul><li><strong>当前线程</strong>调用 <code>t.join()</code> 方法时，<strong>当前线程</strong>从 <code>RUNNABLE --&gt; WAITING</code> 注意是<strong>当前线程</strong>在<strong>t 线程对象</strong>的监视器上等待</li><li><strong>t 线程</strong>运行结束，或调用了<strong>当前线程</strong>的 interrupt() 时，当前线程从 <code>WAITING --&gt; RUNNABLE</code></li></ul><p>情况 4 <code>RUNNABLE &lt;--&gt; WAITING</code></p><ul><li><strong>当前线程</strong>调用 <code>LockSupport.park()</code> 方法会让<strong>当前线程</strong>从 <code>RUNNABLE --&gt; WAITING</code></li><li>调用 <code>LockSupport.unpark</code>(目标线程) 或调用了线程 的 <code>interrupt()</code> ，会让目标线程从 <code>WAITING --&gt; RUNNABLE</code></li></ul><p>情况 5 <code>RUNNABLE &lt;--&gt; TIMED_WAITING</code></p><p><strong>t 线程</strong>用 <code>synchronized(obj)</code> 获取了对象锁后</p><ul><li>调用 <code>obj.wait(long n)</code> 方法时，<strong>t 线程</strong>从 <code>RUNNABLE --&gt; TIMED_WAITING</code></li><li><strong>t 线程</strong>等待时间超过了 n 毫秒，或调用 <code>obj.notify()</code> ， <code>obj.notifyAll()</code> ，<code>t.interrupt()</code>时 <ul><li>竞争锁成功，<strong>t 线程</strong>从 <code>TIMED_WAITING --&gt; RUNNABLE</code></li><li>竞争锁失败，<strong>t 线程</strong>从 <code>TIMED_WAITING --&gt; BLOCKED</code></li></ul></li></ul><p>情况 6 <code>RUNNABLE &lt;--&gt; TIMED_WAITING</code></p><ul><li><strong>当前线程</strong>调用 <code>t.join(long n)</code> 方法时，<strong>当前线程</strong>从 <code>RUNNABLE --&gt; TIMED_WAITING</code> 注意是当前线程在<strong>t 线程</strong>对象的监视器上等待</li><li><strong>当前线程</strong>等待时间超过了 n 毫秒，或<strong>t 线程</strong>运行结束，或调用了<strong>当前线程</strong>的 <code>interrupt()</code> 时，当前线程从 <code>TIMED_WAITING --&gt; RUNNABLE</code></li></ul><p>情况 7 <code>RUNNABLE &lt;--&gt; TIMED_WAITING</code></p><ul><li><strong>当前线程</strong>调用 <code>Thread.sleep(long n)</code> ，<strong>当前线程</strong>从 <code>RUNNABLE --&gt; TIMED_WAITING</code></li><li><strong>当前线程</strong>等待时间超过了 n 毫秒，<strong>当前线程</strong>从 <code>TIMED_WAITING --&gt; RUNNABLE</code></li></ul><p>情况 8 <code>RUNNABLE &lt;--&gt; TIMED_WAITING</code></p><ul><li><strong>当前线程</strong>调用 <code>LockSupport.parkNanos(long nanos)</code> 或 <code>LockSupport.parkUntil(long millis)</code> 时，<strong>当前线程</strong>从 <code>RUNNABLE --&gt; TIMED_WAITING </code></li><li>调用 <code>LockSupport.unpark</code>(目标线程) 或调用了线程 的 <code>interrupt()</code> ，或是等待超时，会让目标线程从 <code>TIMED_WAITING--&gt; RUNNABLE</code></li></ul><p>情况 9 <code>RUNNABLE &lt;--&gt; BLOCKED</code></p><ul><li><strong>t 线程</strong>用 <code>synchronized(obj)</code> 获取了对象锁时如果竞争失败，从 <code>RUNNABLE --&gt; BLOCKED</code></li><li>持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 <code>BLOCKED</code> 的线程重新竞争，如果其中 <strong>t 线程</strong>竞争 成功，从 <code>BLOCKED --&gt; RUNNABLE</code> ，其它失败的线程仍然 <code>BLOCKED</code></li></ul><p>情况 10 <code>RUNNABLE &lt;--&gt; TERMINATED</code></p><ul><li>当前线程所有代码运行完毕，进入 <code>TERMINATED</code></li></ul>',45),c={},s=(0,l(6262).A)(c,[["render",function(t,e){return(0,o.uX)(),(0,o.CE)("div",null,[r,n,(0,o.Q3)(" more "),a])}]]),p=JSON.parse('{"path":"/program/java/juc/Java%E7%BA%BF%E7%A8%8B.html","title":"Java线程","lang":"zh-CN","frontmatter":{"icon":"dianjikai","date":"2023-10-01T00:00:00.000Z","category":["编程"],"tag":["Java","JUC"],"description":"Java线程的基础了解、方法，五种状态六种状态的深度解剖...","head":[["meta",{"property":"og:url","content":"https://github.com/DUDU-dudu-DUDU/xwblog/xwblog/program/java/juc/Java%E7%BA%BF%E7%A8%8B.html"}],["meta",{"property":"og:site_name","content":"小吴 Blog"}],["meta",{"property":"og:title","content":"Java线程"}],["meta",{"property":"og:description","content":"Java线程的基础了解、方法，五种状态六种状态的深度解剖..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-30T12:49:38.000Z"}],["meta",{"property":"article:author","content":"xiaowu"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:tag","content":"JUC"}],["meta",{"property":"article:published_time","content":"2023-10-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-30T12:49:38.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java线程\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-10-01T00:00:00.000Z\\",\\"dateModified\\":\\"2025-03-30T12:49:38.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"xiaowu\\",\\"url\\":\\"https://dudu-dudu-dudu.github.io/xwblog/zh/\\"}]}"]]},"headers":[{"level":2,"title":"Java线程","slug":"java线程-1","link":"#java线程-1","children":[]},{"level":2,"title":"查看线程方法","slug":"查看线程方法","link":"#查看线程方法","children":[]},{"level":2,"title":"线程运行原理","slug":"线程运行原理","link":"#线程运行原理","children":[]},{"level":2,"title":"常见方法","slug":"常见方法","link":"#常见方法","children":[{"level":3,"title":"start 与 run","slug":"start-与-run","link":"#start-与-run","children":[]},{"level":3,"title":"sleep与 yield","slug":"sleep与-yield","link":"#sleep与-yield","children":[]}]},{"level":2,"title":"五种状态与六种状态","slug":"五种状态与六种状态","link":"#五种状态与六种状态","children":[{"level":3,"title":"五种状态","slug":"五种状态","link":"#五种状态","children":[]},{"level":3,"title":"六种状态详解","slug":"六种状态详解","link":"#六种状态详解","children":[]}]}],"git":{"createdTime":1743338978000,"updatedTime":1743338978000,"contributors":[{"name":"DUDU","email":"930824238@qq.com","commits":1}]},"readingTime":{"minutes":7.91,"words":2372},"filePathRelative":"program/java/juc/Java线程.md","localizedDate":"2023年10月1日","excerpt":"\\n<p>Java线程的基础了解、方法，五种状态六种状态的深度解剖...</p>\\n","autoDesc":true}')}}]);