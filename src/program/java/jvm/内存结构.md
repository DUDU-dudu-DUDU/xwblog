---
icon: dianjikai
date: 2023-10-01
category:
  - 编程
tag:
  - Java
  - JVM
---
# 内存结构
jvm内存结构
<!-- more -->

1. 程序计数器

   - 记录下一条jvm指令的执行地址
   - 线程是私有的
   - 不会存在内存溢出

2. 虚拟机栈

   - 每个线程运行时所需的内存 称为虚拟机栈
   - 每个栈由多个栈帧组成  对应每次方法调用时所占的内存
   - 每个线程只有一个活动栈帧，对应着当前正在执行的那个方法
   - **排查cpu过高问题：**
     - 通过 top命令定位那个进程cpu过高
     - 再通过ps H -eo pid,tid,%cpu | grep 进程id  查看该进程那个线程占用过高
     - 再通过 jstack 进程Id 查看该进程下全部线程  通过转换成16机制  查看对应线程  确认问题代码

3. 本地方法栈

   - 针对那些非java代码实现的方法  如c++方法 运行所占用的栈空间  native

4. 堆

   - 线程共享的  堆中的对象都要考虑线程安全问题
   - 通过new关键字 创建的对象放在堆中
   - 有垃圾回收机制
   - **堆内存诊断**
     - jps 查看运行的java进程
     - 再通过  jmap -heap 进程ID 可以查看堆内存占用情况
     - 也可以通过图形界面工具协助排查问题  jvisualvm

5. 方法区

   - 线程共享的  
   - 方法区只是一个规范（概念）  可以对其进行不同的实现（永久代 元空间）  可以在堆中  也可以不在
   - 包含类Class的信息，类加载器，运行时常量池，StringTable
     - **常量池** 就是一张表，虚拟指令根据这张常量表找到要执行的类名，方法名，参数类型，字面量等信息
     - **运行时常量池**  常量池是*.class文件中的，该类被加载，常量池中的信息就会放内存当中（运行时常量池），并把符合地址变成真实地址（真实的内存位置）
   - StringTable
     - 常量池中的字符串仅是符号，第一次用到才变成对象
     - 利用串池的机制，来避免重复创建字符串对象
     - 字符串变量拼接的原理是StringBulider
     - 字符串常量拼接的原理是编辑期的优化
     - 可以使用intern方法，主动将串池中还没有的字符串对象放入串池
     - 调优：-XX:StringTableSize=桶个数 ；考虑将字符串对象入池减少堆内存的使用（串池可以去重）

6. 直接内存

   - 常用于NIO操作时，用于数据缓冲区
   - 分配回收成本高，但读写性能高
   - 不受JVM内存回收管理。

   