"use strict";(self.webpackChunkxwblog=self.webpackChunkxwblog||[]).push([[4332],{66262:(i,s)=>{s.A=(i,s)=>{const t=i.__vccOpts||i;for(const[i,a]of s)t[i]=a;return t}},78523:(i,s,t)=>{i.exports=t.p+"assets/img/20250815205353.0b38f9c7.png"},52121:(i,s,t)=>{t.r(s),t.d(s,{comp:()=>o,data:()=>g});var a=t(20641);const n=t.p+"assets/img/MySQL体系结构.e8e9af1c.png",l=t.p+"assets/img/20250813214747.4e634c39.png",e=t.p+"assets/img/20250813195622.8049b007.png";var r=t(78523);const d=(0,a.Lk)("h1",{id:"mysql基础",tabindex:"-1"},[(0,a.Lk)("a",{class:"header-anchor",href:"#mysql基础"},[(0,a.Lk)("span",null,"Mysql基础")])],-1),h=(0,a.Lk)("p",null,"打牢基础 窥其真容",-1),p=(0,a.Fv)('<h2 id="_1、mysql执行原理" tabindex="-1"><a class="header-anchor" href="#_1、mysql执行原理"><span>1、Mysql执行原理</span></a></h2><h3 id="_1-1-mysql层级结构" tabindex="-1"><a class="header-anchor" href="#_1-1-mysql层级结构"><span>1.1 mysql层级结构</span></a></h3><figure><img src="'+n+'" alt="1751464621146" tabindex="0" loading="lazy"><figcaption>1751464621146</figcaption></figure><ol><li><p><strong>连接层</strong></p><p>最上层是一些客户端和链接服务，包含本地sock 通信和大多数基于客户端/服务端工具实现的类似于 TCP/IP的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程 池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务 器也会为安全接入的每个客户端验证它所具有的操作权限。</p></li><li><p><strong>服务层</strong></p><p>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部 分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如 过程、函数等。在该层，服务器会解 析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询的顺序，是否利用索引等， 最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存，如果缓存空间足够大， 这样在解决大量读操作的环境中能够很好的提升系统的性能。</p></li><li><p><strong>引擎层</strong></p><p>存储引擎层， 存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通 信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。数据库 中的索引是在存储引擎层实现的。</p></li><li><p><strong>存储层</strong></p><p>数据存储层， 主要是将数据(如: redolog、undolog、数据、索引、二进制日志、错误日志、查询 日志、慢查询日志等)存储在文件系统之上，并完成与存储引擎的交互。 和其他数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要 体现在存储引擎上，插件式的存储引擎架构，将查询处理和其他的系统任务以及数据的存储提取分离。 这种架构可以根据业务的需求和实际需要选择合适的存储引擎。</p></li></ol><p><strong>Mysql主要分为两层</strong>，来实现可插拔式的框架：</p><p><strong>Server层</strong>：包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p><ul><li><strong>连接器</strong>：第一步，你会先连接到这个数据库上，这时候接待你的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。我们可以通过 TCP/IP ，命名管道和共享内存 ，Unix域套接字文件 等方式进行连接的建立。当连接到服务器时，服务器会对密码，用户名，进行验证。如果用户名或密码不对，你就会收到一个 “Access denied for user” 的错误，然后客户端程序结束执行。如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。</li><li><strong>分析器</strong>：MySQL 需要知道你要做什么，因此需要对 SQL 语句做解析。分析器先会做“词法分析”。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。MySQL 从你输入的 “select” 这个关键字识别出来，这是一个查询语句。它也要把字符串 “T” 识别成 “表名T”，把字符串 “ID” 识别成 “列ID”。做完了这些识别以后，就要做“语法分析”。据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个SQL语句是否满足 MySQL 语法。如果你的语句不对，就会收到 “You have an error in your SQL syntax” 的错误提醒。</li><li><strong>优化器</strong>：MySQL就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。</li><li><strong>执行器</strong>：MySQL 通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误。如果有权限，就打开表继续执行。打开表的时候，优化器就会根据表的引擎定义，去使用这个引擎提供的接口。对于有索引的执行逻辑也差不多，第一次调用“取满足条件的第一行”这个接口 ，然后循环取“满足条件的下一行”这个接口 。这些接口存储引擎已经定义好了。慢查询日志有个rows_examined的字段表示语句执行过程扫描了多少行，就是执行器每次调用引擎获取数据时累加的，但有时候，执行器调用一次，引擎扫描了多行，所以这个数和行数并不是完全关联的。</li></ul><p><strong>存储引擎层</strong>：是一个可插拔的设计，也就是我们可以随意选择具体的存储引擎。server端通过API与存储引擎进行通信，这些接口屏蔽了不同存储引擎的差异。 支持 InnoDB、MyISAM、Memory 等多个存储引擎。从 MySQL 5.5 版本开始， InnoDB 成为了 MySQL 的默认存储引擎。</p><p><strong>为什么要分为两层</strong>来实现呢 这就是Mysql的重点：</p><p><strong>1. 职责分离原则</strong></p><table><thead><tr><th><strong>层级</strong></th><th><strong>职责</strong></th><th><strong>关键组件</strong></th></tr></thead><tbody><tr><td><strong>Server 层</strong></td><td>处理与存储无关的通用逻辑： • SQL 解析/优化 • 权限验证 • 连接管理 • 内置函数</td><td>解析器、优化器、查询缓存、Binlog</td></tr><tr><td><strong>引擎层</strong> (InnoDB)</td><td>处理数据存储和事务： • 数据读写 • 索引管理 • 事务 ACID 实现 • 崩溃恢复</td><td>Buffer Pool、Redo Log、Undo Log</td></tr></tbody></table><p><strong>2. 可插拔架构优势</strong></p><ul><li>灵活替换引擎：用户可根据需求选择不同存储引擎（如 InnoDB、MyISAM、Memory），而 Server 层逻辑无需修改。</li><li>解耦开发：存储引擎团队（如 InnoDB）和 Server 层团队可独立优化代码。</li></ul><p><strong>3. 性能优化</strong></p><ul><li>Server 层专注<strong>计算密集型</strong>操作（如 SQL 优化）</li><li>InnoDB 层专注<strong>磁盘 I/O 密集型</strong>操作（如数据存取）</li></ul><h3 id="_1-2-mysql执行流程" tabindex="-1"><a class="header-anchor" href="#_1-2-mysql执行流程"><span>1.2 Mysql执行流程</span></a></h3><p>（一次事务提交）流程图 让你一眼看穿其本质</p><figure><img src="'+l+'" alt="1751464621146" tabindex="0" loading="lazy"><figcaption>1751464621146</figcaption></figure><p><strong>关键协作点</strong>：</p><ol><li><strong>二阶段提交</strong>（XA 协议）： <ul><li><strong>Prepare 阶段</strong>：InnoDB 写 Redo Log (Prepare)</li><li><strong>Commit 阶段</strong>：Server 写 Binlog → InnoDB 提交 Redo Log</li></ul></li><li><strong>崩溃恢复</strong>： <ul><li>检查 Binlog 和 Redo Log 的一致性</li><li>若 Binlog 完整则提交事务（Redo 重放），否则回滚（Undo 回滚）</li></ul></li></ol><p>现在这里留个看不懂的 详细介绍我们后面再讲~</p><h3 id="_1-3-存储引擎" tabindex="-1"><a class="header-anchor" href="#_1-3-存储引擎"><span>1.3 存储引擎</span></a></h3><p>上面我们介绍了什么是存储引擎，以及如何在建表时如何指定存储引擎，接下来我们就来介绍下来上面</p><p>重点提到的三种存储引擎 InnoDB、MyISAM、Memory的特点。</p><h4 id="_1-3-1-innodb" tabindex="-1"><a class="header-anchor" href="#_1-3-1-innodb"><span>1.3.1 Innodb</span></a></h4><p>InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB是默认的 MySQL 存储引擎。</p><ol><li><p>特点</p><ul><li><p>DML操作遵循ACID模型，支持事务；</p></li><li><p>行级锁，提高并发访问性能；</p></li><li><p>支持多版本并发控制机制（MVCC）</p></li><li><p>支持聚簇索引</p></li><li><p>支持数据缓存</p></li><li><p>支持外键</p></li><li><p>64TB</p></li></ul></li><li><p>文件</p><p>xxx.ibd：xxx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm-早期的 、sdi-新版的）、数据和索引。</p><p>参数：innodb_file_per_table</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">show variables </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">like</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;innodb_file_per_table&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>如果该参数开启，代表对于InnoDB引擎的表，每一张表都对应一个ibd文件。 我们直接打开MySQL的 数据存放目录： 这个目录下有很多文件夹，不同的文件夹代表不同的数据库。</p><figure><img src="'+e+'" alt="1755086196133" tabindex="0" loading="lazy"><figcaption>1755086196133</figcaption></figure><p>而在这个ibd文件中不仅存放表结构、数据，还会存放该表对应的 索引信息。 而该文件是基于二进制存储的，不能直接基于记事本打开，我们可以使用mysql提供的一 个指令 ibd2sdi ，通过该指令就可以从ibd文件中提取sdi信息，而sdi数据字典信息中就包含该表的表结构。</p></li><li><p>存储格式</p><figure><img src="'+r+'" alt="1755086196133" tabindex="0" loading="lazy"><figcaption>1755086196133</figcaption></figure><ol><li><strong>表空间</strong> : InnoDB存储引擎逻辑结构的最高层，ibd文件其实就是表空间文件，在表空间中可以 包含多个Segment段。</li><li><strong>段</strong> : 表空间是由各个段组成的， 常见的段有数据段、索引段、回滚段等。InnoDB中对于段的管 理，都是引擎自身完成，不需要人为对其控制，一个段中包含多个区。</li><li><strong>区</strong> : 区是表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为 16K， 即一个区中一共有64个连续的页。</li><li><strong>页</strong> : 页是组成区的最小单元，<strong>页也是InnoDB存储引擎磁盘管理的最小单元</strong>，每个页的大小默 认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。</li><li><strong>行</strong> : InnoDB 存储引擎是面向行的，也就是说数据是按行进行存放的，在每一行中除了定义表时 所指定的字段以外，还包含两个隐藏字段(后面会详细介绍)。</li></ol></li></ol><h4 id="_1-3-2-myisam" tabindex="-1"><a class="header-anchor" href="#_1-3-2-myisam"><span>1.3.2 myISAM</span></a></h4><p>MySQL5.5.5前默认的数据库引擎，在只读（或者写较少）、表较小（可以接受长时间进行修复操作）的场景适用</p><ol><li>缺点： <ul><li>不支持事务</li><li>最小粒度锁：表级</li><li>读写相互阻塞，写入不能读，读时不能写</li><li>不支持MVCC（支持多版本并发控制机制）</li><li>不支持聚簇索引</li><li>不支持数据缓存，只支持索引缓存</li><li>不支持外键</li><li>崩溃恢复性较差</li></ul></li><li>优点： <ul><li>最大支持256TB存储空间</li><li>读取数据较快，占用资源较少</li><li>直接记录了select count（0）的值</li></ul></li><li>存储文件： <ul><li>tbl_name.frm: 表格式定义</li><li>tbl_name.MYD: 数据文件</li><li>tbl_name.MYI: 索引文件</li></ul></li></ol><h4 id="_1-3-3-memory" tabindex="-1"><a class="header-anchor" href="#_1-3-3-memory"><span>1.3.3 memory</span></a></h4><p>所有的数据都保存在内存中，不需要进行磁盘I/O。Memory表的结构在重启以后还会保留，但数据会丢失。 Memroy表在很多场景可以发挥好的作用:</p><ul><li>用于查找(lookup) 或者映射(mapping) 表，例如将邮编和州名映射的表。</li><li>用于缓存周期性聚合数据( periodically aggregated data)的结果。</li><li>用于保存数据分析中产生的中间数据。</li></ul><p>基本可以被Redis替代了</p><h3 id="_1-4-执行计划" tabindex="-1"><a class="header-anchor" href="#_1-4-执行计划"><span>1.4 执行计划</span></a></h3><p>当我们对一条sql进行执行计划分析时 会得到下列字段</p><table><thead><tr><th><strong>字段名</strong></th><th>说明</th><th>关键值示例及含义</th></tr></thead><tbody><tr><td><strong>id</strong></td><td>查询标识符</td><td><code>1</code>：简单查询 <code>2</code>：子查询（数值越大优先级越高）</td></tr><tr><td><strong>select_type</strong></td><td>查询类型</td><td><code>SIMPLE</code>：简单查询 <code>PRIMARY</code>：外层查询 <code>SUBQUERY</code>：子查询</td></tr><tr><td><strong>table</strong></td><td>访问的表名</td><td><code>user</code>：主表 <code>&lt;derived2&gt;</code>：临时表（衍生自id=2的子查询）</td></tr><tr><td><strong>partitions</strong></td><td>匹配的分区</td><td><code>p0,p1</code>：查询涉及的分区 <code>NULL</code>：非分区表</td></tr><tr><td><strong>type</strong></td><td><strong>访问类型</strong>（性能关键指标）</td><td><code>const</code>：唯一索引查询 <code>ref</code>：非唯一索引 <code>ALL</code>：全表扫描（需优化） <code>range</code>：索引范围扫描</td></tr><tr><td><strong>possible_keys</strong></td><td>可能使用的索引</td><td><code>idx_name</code>：候选索引列表 <code>NULL</code>：无可用索引</td></tr><tr><td><strong>key</strong></td><td><strong>实际使用的索引</strong></td><td><code>PRIMARY</code>：主键索引 <code>idx_age</code>：二级索引 <code>NULL</code>：未使用索引</td></tr><tr><td><strong>key_len</strong></td><td>索引使用的字节数</td><td><code>4</code>：int类型索引长度 <code>152</code>：varchar(50)索引长度（UTF8=3字节×50+2额外字节）</td></tr><tr><td><strong>ref</strong></td><td>索引关联的列</td><td><code>const</code>：常量值 <code>db.user.id</code>：关联其他表的列</td></tr><tr><td><strong>rows</strong></td><td>预估扫描行数（核心性能指标）</td><td><code>1</code>：精确匹配 <code>1832</code>：全表扫描行数（值越大性能越差）</td></tr><tr><td><strong>filtered</strong></td><td>存储引擎返回数据后，在Server层过滤的百分比</td><td><code>10.0</code>：仅10%数据满足条件 <code>100.0</code>：无需额外过滤</td></tr><tr><td><strong>Extra</strong></td><td><strong>额外执行信息</strong>（优化关键提示）</td><td><code>Using index</code>：覆盖索引 <code>Using where</code>：Server层过滤 <code>Using filesort</code>：需文件排序（需优化）</td></tr></tbody></table><p>关键字解读：</p><h4 id="_1-4-1-type字段" tabindex="-1"><a class="header-anchor" href="#_1-4-1-type字段"><span>1.4.1 type字段</span></a></h4><p>（访问类型性能排序） <code>system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL</code></p><table><thead><tr><th><strong>类型值</strong></th><th>含义及触发场景</th><th>示例 SQL</th></tr></thead><tbody><tr><td><strong>system</strong></td><td>表只有一行记录（系统表），是 const 的特例</td><td><code>SELECT * FROM mysql.proxies_priv WHERE ...</code></td></tr><tr><td><strong>const</strong></td><td>通过主键/唯一索引找到唯一记录，优化器视为常量</td><td><code>SELECT * FROM user WHERE id = 1;</code>（id 是主键）</td></tr><tr><td><strong>eq_ref</strong></td><td>多表 JOIN 时，对于前表每一行，后表只有一行匹配（主键/唯一索引 JOIN）</td><td><code>SELECT * FROM user u JOIN order o ON u.id = o.user_id;</code>（o.user_id 是主键）</td></tr><tr><td><strong>ref</strong></td><td>使用非唯一索引扫描，返回匹配某个值的所有行</td><td><code>SELECT * FROM user WHERE age = 20;</code>（age 有非唯一索引）</td></tr><tr><td><strong>fulltext</strong></td><td>使用全文索引进行查询（MySQL 5.6+）</td><td><code>SELECT * FROM article WHERE MATCH(content) AGAINST(&#39;keyword&#39;);</code></td></tr><tr><td><strong>ref_or_null</strong></td><td>类似 ref，但包含对 NULL 值的搜索</td><td><code>SELECT * FROM user WHERE age=20 OR age IS NULL;</code>（age 有索引）</td></tr><tr><td><strong>index_merge</strong></td><td>使用多个索引组合查询（OR 条件合并）</td><td><code>SELECT * FROM user WHERE name=&#39;Alice&#39; OR age=20;</code>（name 和 age 都有索引）</td></tr><tr><td><strong>unique_subquery</strong></td><td>子查询中使用主键/唯一索引（效率高）</td><td><code>WHERE id IN (SELECT user_id FROM order WHERE ...)</code>（user_id 是主键）</td></tr><tr><td><strong>index_subquery</strong></td><td>类似 unique_subquery，但子查询中使用非唯一索引</td><td><code>WHERE id IN (SELECT product_id FROM order WHERE ...)</code>（非唯一索引）</td></tr><tr><td><strong>range</strong></td><td>索引范围扫描（BETWEEN, IN, &gt;, &lt; 等）</td><td><code>SELECT * FROM user WHERE age BETWEEN 20 AND 30;</code></td></tr><tr><td><strong>index</strong></td><td>全索引扫描（遍历整个索引树）</td><td><code>SELECT name FROM user;</code>（name 有索引，且 SELECT 只需要索引字段）</td></tr><tr><td><strong>ALL</strong></td><td>全表扫描（无索引或未使用索引）</td><td><code>SELECT * FROM user WHERE phone=&#39;13800138000&#39;;</code>（phone 无索引）</td></tr></tbody></table><h4 id="_1-4-2-extra字段" tabindex="-1"><a class="header-anchor" href="#_1-4-2-extra字段"><span>1.4.2 Extra字段</span></a></h4><table><thead><tr><th><strong>Extra 值</strong></th><th>含义及优化建议</th></tr></thead><tbody><tr><td><strong>Using index</strong></td><td>覆盖索引（查询的列都在索引中），无需回表，性能最佳</td></tr><tr><td><strong>Using index condition</strong></td><td>索引条件下推（ICP），5.6+ 特性，在引擎层过滤数据，减少回表次数</td></tr><tr><td><strong>Using where</strong></td><td>Server 层对存储引擎返回的数据进行了过滤（需检查是否可下推到引擎层）</td></tr><tr><td><strong>Using temporary</strong></td><td>使用临时表保存中间结果（常见于 GROUP BY、ORDER BY），考虑优化索引或查询结构</td></tr><tr><td><strong>Using filesort</strong></td><td>使用外部排序（非索引排序），数据量大时性能差，需优化 ORDER BY</td></tr><tr><td><strong>Using join buffer</strong></td><td>使用 JOIN 缓存（Block Nested Loop），连接字段无索引时发生，考虑添加索引</td></tr><tr><td><strong>Select tables optimized away</strong></td><td>优化器已优化（如 MyISAM 的 COUNT(*) 直接返回值）</td></tr><tr><td><strong>Impossible WHERE</strong></td><td>WHERE 条件永远为假（如 <code>WHERE 1=0</code>）</td></tr><tr><td><strong>Distinct</strong></td><td>优化 DISTINCT 操作，找到第一个匹配后停止搜索</td></tr><tr><td><strong>No tables used</strong></td><td>查询无 FROM 子句（如 <code>SELECT 1+1</code>）</td></tr></tbody></table><h3 id="_1-5-关键字执行分析" tabindex="-1"><a class="header-anchor" href="#_1-5-关键字执行分析"><span>1.5 关键字执行分析</span></a></h3><h4 id="_1-5-1-count" tabindex="-1"><a class="header-anchor" href="#_1-5-1-count"><span>1.5.1 count</span></a></h4><ol><li><p><strong>count(主键)</strong> InnoDB 引擎会遍历整张表（<strong>优先选择最小的二级索引</strong>），把每一行的主键id值取出来，返回给服务层。服务层直接按行累加（主键非空）。</p></li><li><p><strong>count(字段)</strong></p><ul><li><strong>没有not null 约束</strong> : InnoDB 引擎遍历整张表取出每一行的字段值返回服务层，服务层判断非 null 后累加。</li><li><strong>有not null 约束</strong>：InnoDB 引擎遍历整张表取出每一行的字段值返回服务层，服务层直接累加。</li></ul></li><li><p><strong>count(数字)</strong> InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一行，放一个数字“1” 进去，直接按行进行累加。</p></li><li><p><strong>count(*)</strong> InnoDB引擎并不会把全部字段取出来，而是专门做了优化，不取值，优先使用<code>information_schema.INNODB_METRICS</code>的近似计数。</p></li><li><p><strong>为什么推荐 count(*)</strong></p><ul><li>SQL 标准规范，所有数据库通用</li><li>MySQL 对 count(*) 有专门优化</li><li>count(1) 在 MySQL 中无性能差异但不具通用性</li></ul></li></ol><h4 id="_1-5-2-limit" tabindex="-1"><a class="header-anchor" href="#_1-5-2-limit"><span>1.5.2 limit</span></a></h4><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> t </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">LIMIT</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 5000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>执行过程</strong>：读取5001行 → Server层<strong>丢弃</strong>前5000行 → 返回最后1行</p><p><strong>性能陷阱</strong>：二级索引需5001次回表，优化器可能选择全表扫描</p><p>优化方案：</p><ol><li><p><strong>深翻页</strong></p><p>如果一个表的id是<strong>有序递增</strong>的 那么就可以使用深翻页的方案优化limit，举个简单的例子</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> t </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">ORDER BY</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">LIMIT</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">100</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">--第一页</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> t </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">ORDER BY</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">LIMIT</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 100</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">100</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">--第二页</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> t </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">ORDER BY</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">LIMIT</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 200</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">100</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">--第三页</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>优化后</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> t </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">where</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> ORDER BY</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">LIMIT</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">100</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">--第一页</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> t </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">where</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">100</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> ORDER BY</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">LIMIT</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">100</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">--第二页</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> t </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">where</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">200</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> ORDER BY</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">LIMIT</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">100</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">--第三页</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>覆盖索引 + JOIN</strong></p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">/* 通用优化模板 */</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> cols </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> table</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">JOIN</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> pk </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> table</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  WHERE</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> [条件]</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> ORDER BY</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> sort_cols</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  LIMIT</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 100000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">100</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">  -- 深分页位置</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">AS</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> tmp </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">USING</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(pk)</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">ORDER BY</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> sort_cols;  </span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">-- 保持顺序</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>避免 OFFSET 造成的无用扫描</li><li>利用覆盖索引减少回表</li><li>支持多字段排序和ID不连续场景</li></ul></li></ol><h4 id="_1-5-3-order-by" tabindex="-1"><a class="header-anchor" href="#_1-5-3-order-by"><span>1.5.3 order by</span></a></h4><ol><li><p><strong>全字段排序</strong></p><div class="language-mermaid line-numbers-mode" data-highlighter="shiki" data-ext="mermaid" data-title="mermaid" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">graph TD</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  A[初始化 sort_buffer] --&gt; B[从索引取数据]</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  B --&gt; C{数据量 &lt; sort_buffer_size?}</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  C -- 是 --&gt; D[内存排序]</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  C -- 否 --&gt; E[磁盘临时文件+归并排序]</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  D --&gt; F[返回结果]</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  E --&gt; F</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>MySQL 会给每个查询线程分配一块小内存，用于排序的，称为 sort_buffer。什么时候把字段放进去排序呢，其实是通过排序字段命中索引时找到对应的数据，才把数据放进去啦。</p><p>**适用场景：**SELECT字段总长度 ≤ <strong>max_length_for_sort_data</strong></p><p>整体的<strong>执行流程</strong>就是：</p><ol><li>从主键索引树或二级索引树遍历满足条件的数据，分批存入 <strong>sort_buffer</strong>。</li><li>当 <strong>sort_buffer 内存不足</strong>时，对当前缓冲区内的数据按排序字段（如 age）快速排序，并将排序结果写入磁盘临时文件（生成一个有序的小文件）。</li><li>清空 sort_buffer，继续读取下一批数据，重复上述排序和写入操作，直到遍历完所有符合条件的数据。最终生成多个有序的磁盘临时文件。</li><li>对所有临时文件执行多路归并排序（Merge Sort）： <ul><li>MySQL 为每个临时文件维护一个指向当前排序记录的指针。</li><li>比较所有临时文件的指针指向的记录，选择符合排序规则（如 age 最小）的记录，写入最终的合并文件。</li><li>移动被选中记录的指针，继续比较和选择，直到所有临时文件的数据被完全合并。</li></ul></li><li>最终生成一个全局有序的<strong>磁盘大文件</strong>。</li><li>从合并后的有序文件中按需读取数据（如 LIMIT 10），跳过不需要的行，仅返回最终结果集给客户端。</li></ol></li><li><p><strong>rowid 排序</strong></p><p><strong>适用场景</strong>：字段总长度 &gt; <strong>max_length_for_sort_data</strong></p><p>rowid 排序就是，只把查询SQL需要用于排序的字段和主键id，放到sort_buffer中。那怎么确定走的是全字段排序还是rowid 排序排序呢？</p><p>实际上有个参数控制的。这个参数就是<strong>max_length_for_sort_data</strong>，它表示MySQL用于排序行数据的长度的一个参数，如果单行的长度超过这个值，MySQL 就认为单行太大，就换rowid 排序。</p><p>使用rowid 排序的话，整个SQL执行流程又是怎样的呢？</p><ol><li>初始化 sort_buffer 仅加载排序字段 age 和主键 id。</li><li>检索满足条件的记录 从 索引树 定位 name = &#39;dudu&#39; 的首个主键 id。</li><li>回表查询主键索引，提取 age 和 id 存入 sort_buffer。</li><li>重复上述步骤直至遍历完所有 name = &#39;dudu&#39; 的记录。</li><li>排序与回表 在 sort_buffer 中对 age 字段排序。取排序后前 10 行的 id，回表提取完整数据（city、name、age）。</li></ol><p>对比一下全字段排序的流程，rowid 排序<strong>多了一次回表</strong></p><p><strong>rowid 排序</strong>与<strong>全字段排序</strong>的关键区别</p><table><thead><tr><th>对比项</th><th>全字段排序</th><th>RowID 排序</th></tr></thead><tbody><tr><td>sort_buffer 内容</td><td>包含所有 SELECT 字段</td><td>仅排序字段 + 主键</td></tr><tr><td>回表次数</td><td>无需回表（数据已加载）</td><td>额外回表（取非排序字段）</td></tr><tr><td>内存消耗</td><td>较高（存储更多字段）</td><td>较低</td></tr></tbody></table><p>我们如何<strong>优化order by</strong>语句呢？</p><ul><li><p><strong>索引优化</strong></p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">/* 联合索引覆盖 WHERE + ORDER BY */</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">ALTER</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> TABLE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> user </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">ADD</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> INDEX</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> idx_city_age(city, age);</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">/* 8.0+ 降序索引 */</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">CREATE</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> INDEX</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> idx_created_desc</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> ON</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> orders(created_at </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">DESC</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">/* 8.0+ 函数索引 */</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">CREATE</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> INDEX</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> idx_date</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> ON</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> orders((</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">DATE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(create_time)));</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>参数调优</strong></p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SET</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> max_length_for_sort_data </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 8192</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;  </span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">-- 增大内存排序阈值</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SET</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> sort_buffer_size </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> 64M;           </span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">-- 增大排序缓冲区</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>冷热数据分离</strong></p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">-- 热数据（最近3个月）</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">CREATE</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> TABLE</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> orders_hot</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> LIKE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> orders;</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">ALTER</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> TABLE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> orders_hot </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">ADD</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> INDEX</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> hot_idx(create_time);</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">-- 查询时组合</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> orders_hot </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">ORDER BY</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> create_time </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">LIMIT</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 100</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">UNION ALL</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> orders_archive ... );</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li></ol><h4 id="_1-5-4-group-by" tabindex="-1"><a class="header-anchor" href="#_1-5-4-group-by"><span>1.5.4 group by</span></a></h4><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">explain </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> city ,</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">count</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(*) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">as</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> num </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> staff </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">group by</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> city;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这样一条group by语句</p><ul><li>Extra 这个字段的Using temporary表示在执行分组的时候使用了临时表</li><li>Extra 这个字段的Using filesort表示使用了排序</li></ul><p>group by 怎么就使用到临时表和排序了呢？我们来看下这个SQL的执行流程</p><ol><li>创建内存临时表，表里有两个字段city和num；</li><li>全表扫描staff的记录，依次取出city = &#39;X&#39;的记录。</li><li>判断临时表中是否有为 city=&#39;X&#39;的行，没有就插入一个记录 (X,1);</li><li>如果临时表中有city=&#39;X&#39;的行的行，就将x 这一行的num值加 1；</li><li>遍历完成后，再根据字段city做排序，得到结果集返回给客户端。</li></ol><p>三种分组实现机制对比：<strong>松散索引扫描</strong>、<strong>紧凑索引扫描</strong>、<strong>临时表</strong></p><table><thead><tr><th>机制</th><th>触发条件</th><th>资源消耗</th><th>效率</th><th>Extra字段</th></tr></thead><tbody><tr><td>松散索引扫描</td><td>- GROUP BY字段为索引最左连续字段 - 仅用MIN/MAX聚合函数</td><td>极低</td><td>⭐⭐⭐⭐</td><td>Using index for group-by</td></tr><tr><td>紧凑索引扫描</td><td>索引覆盖GROUP BY字段但非最左连续</td><td>中</td><td>⭐⭐⭐</td><td>Using index</td></tr><tr><td>临时表</td><td>无合适索引可用</td><td>高</td><td>⭐⭐</td><td>Using temporary; Using filesort</td></tr></tbody></table><ol><li><p><strong>松散索引</strong></p><ul><li><p>触发限制：</p><ol><li><p>GROUP BY字段构成索引最左前缀（如索引(a,b,c)，GROUP BY需a或a,b等）</p></li><li><p>仅允许MAX()/MIN()聚合函数</p></li><li><p>非GROUP BY字段需为常量（如WHERE b=1中b不在GROUP BY时）</p></li></ol></li></ul><p>为什么松散索引扫描的效率会很高?</p><p>因为在没有WHERE子句，也就是必须经过全索引扫描的时候， 松散索引扫描需要读取的键值数量与分组的组数量一样多，也就是说比实际存在的键值数目要少很多。而在WHERE子句包含范围判断式或者等值表达式的时候， 松散索引扫描查找满足范围条件的每个组的第1个关键字，并且再次读取尽可能最少数量的关键字。</p><p>核心优势 通过跳跃式扫描索引，仅访问每组第一条记录，减少数据读取量。</p><p>执行逻辑：</p><p>索引树遍历 → 遇到新组别 → 记录首条数据 → 跳跃到下一组起始位置</p></li><li><p><strong>紧凑索引</strong></p><p>和松散索引扫描的区别是需要读取所有满足条件的索引值，之后取数据完成操作。 Extra中不显示for group-by 在 MySQL 中，首先会选择尝试通过松散索引扫描来实现 GROUP BY 操作，当发现某些情况无法满足松散索引扫描实现 GROUP BY 的要求之后，才会尝试通过紧凑索引扫描来实现。（比如GROUP BY 条件字段并不连续或者不是索引前缀部分的时候）</p></li><li><p><strong>临时表</strong></p><p>当无法找到合适的索引可以利用的时候，就不得不先读取需要的数据，然后通过临时表来完成 GROUP BY 操作。Extra：Using temporary; Using filesort</p></li></ol>',63),k={},o=(0,t(66262).A)(k,[["render",function(i,s){return(0,a.uX)(),(0,a.CE)("div",null,[d,h,(0,a.Q3)(" more "),p])}]]),g=JSON.parse('{"path":"/program/mysql/Mysql%E5%9F%BA%E7%A1%80.html","title":"Mysql基础","lang":"zh-CN","frontmatter":{"totail":null,"icon":"book","date":"2024-10-01T00:00:00.000Z","category":["编程"],"tag":["Mysql"],"description":"打牢基础 窥其真容","head":[["meta",{"property":"og:url","content":"https://github.com/DUDU-dudu-DUDU/xwblog/xwblog/program/mysql/Mysql%E5%9F%BA%E7%A1%80.html"}],["meta",{"property":"og:site_name","content":"小吴 Blog"}],["meta",{"property":"og:title","content":"Mysql基础"}],["meta",{"property":"og:description","content":"打牢基础 窥其真容"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-31T03:13:03.000Z"}],["meta",{"property":"article:author","content":"xiaowu"}],["meta",{"property":"article:tag","content":"Mysql"}],["meta",{"property":"article:published_time","content":"2024-10-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-31T03:13:03.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Mysql基础\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-10-01T00:00:00.000Z\\",\\"dateModified\\":\\"2025-08-31T03:13:03.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"xiaowu\\",\\"url\\":\\"https://dudu-dudu-dudu.github.io/xwblog/zh/\\"}]}"]]},"headers":[{"level":2,"title":"1、Mysql执行原理","slug":"_1、mysql执行原理","link":"#_1、mysql执行原理","children":[{"level":3,"title":"1.1 mysql层级结构","slug":"_1-1-mysql层级结构","link":"#_1-1-mysql层级结构","children":[]},{"level":3,"title":"1.2 Mysql执行流程","slug":"_1-2-mysql执行流程","link":"#_1-2-mysql执行流程","children":[]},{"level":3,"title":"1.3 存储引擎","slug":"_1-3-存储引擎","link":"#_1-3-存储引擎","children":[]},{"level":3,"title":"1.4 执行计划","slug":"_1-4-执行计划","link":"#_1-4-执行计划","children":[]},{"level":3,"title":"1.5 关键字执行分析","slug":"_1-5-关键字执行分析","link":"#_1-5-关键字执行分析","children":[]}]}],"git":{"createdTime":1756609983000,"updatedTime":1756609983000,"contributors":[{"name":"DUDU","email":"930824238@qq.com","commits":1}]},"readingTime":{"minutes":20.56,"words":6169},"filePathRelative":"program/mysql/Mysql基础.md","localizedDate":"2024年10月1日","excerpt":"\\n<p>打牢基础 窥其真容</p>\\n","autoDesc":true}')}}]);