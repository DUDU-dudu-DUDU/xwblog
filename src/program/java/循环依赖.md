---
icon: dianjikai
date: 2024-06-01
category:
  - 编程
tag:
  - spring
---

# 循环依赖

> 首先了解一下spring初始化的流程，单例Bean初始化完成，要经历三步 **实例化**  **属性赋值**   **初始化**。

<!-- more -->

在spring中，a依赖b，b依赖c，c依赖a，形成了一个闭环。在这种情况下，初始化任意一个bean，都会导致最终又依赖回自己，导致初始化失败。

Spring 通过**三级缓存**解决了循环依赖：

1. 一级缓存 : Map<String,Object> singletonObjects，成品对象单例池，用于保存实例化、属性赋值（注入）、初始化完成的 bean 实例
2. 二级缓存 : Map<String,Object> earlySingletonObjects，早期曝光对象，用于保存实例化完成的 bean 实例
3. 三级缓存 : Map<String,ObjectFactory<?>> singletonFactories，早期曝光对象工厂，用于保存 bean 创建工厂，以便于后面扩展有机会创建代理对象。

##### **二级缓存作用** 

**循环依赖加载流程**：

1. A实例化成功

2. A把自己的对象工厂保存在三级缓存

3. A属性赋值依赖了B

4. B实例化成功

5. B把自己对象工厂保存在三级缓存

6. B属性赋值依赖了A，这时候B调用的是复用的getSingleton（beanName）方法。

这时候一级二级都找不到。会找到三级缓存，然后调用对象工厂的获取对象方法，获取到代理后（也可能没代理）对象。把代理对象放到二级缓存中，删除三级缓存。然后返回对应的代理对象。这样B就能成功把A赋值进去了。

之后如果C也依赖了A，也能在二级缓存找到这个代理对象。一直到A自身初始化完毕，会将自己放入一级缓存，同时删除二级缓存。

##### **一级缓存作用**

  

在获取对象的时候，会调用getSingleton（beanName）方法，从一级缓存获取bean。如果不存在，就会调用重载方法getSingleton（beanName，创建方法）创建bean后，把它设置回一级缓存

##### **三级缓存作用**

这里做了几件事，

1. 实例化对象

2. 将对象的创建工厂保存在三级缓存

3. 属性赋值

4. 后置处理器

这里就提前把自己的创建工厂暴露在三级缓存里了，如果出现循环依赖，其它的类就会在属性赋值的时候，从三级缓存取出这个工厂。

对象工厂是干嘛的，其实就是暴露一个早期对象。把所有实现了SmartInstantiationAwareBeanPostProcessor的后置处理器，提前运行。AOP就会提前在这里执行。这玩意就是为了解决循环依赖而生的

##### 总结

**一级缓存**：存储成品对象

**二级缓存**：存储半成品对象

**三级缓存**：存储代理对象工厂（lambda表达式 -> getEarlyReference的执行逻辑）