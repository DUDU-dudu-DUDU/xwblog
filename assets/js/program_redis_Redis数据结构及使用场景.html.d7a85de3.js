"use strict";(self.webpackChunkxwblog=self.webpackChunkxwblog||[]).push([[1557],{6262:(e,l)=>{l.A=(e,l)=>{const i=e.__vccOpts||e;for(const[e,a]of l)i[e]=a;return i}},7358:(e,l,i)=>{i.r(l),i.d(l,{comp:()=>r,data:()=>h});var a=i(641);const t=(0,a.Lk)("h1",{id:"redis数据结构及使用场景",tabindex:"-1"},[(0,a.Lk)("a",{class:"header-anchor",href:"#redis数据结构及使用场景"},[(0,a.Lk)("span",null,"Redis数据结构及使用场景")])],-1),s=(0,a.Fv)('<h2 id="string-字符串" tabindex="-1"><a class="header-anchor" href="#string-字符串"><span>String（字符串）</span></a></h2><h3 id="内部实现" tabindex="-1"><a class="header-anchor" href="#内部实现"><span>内部实现：</span></a></h3><p>String 类型的底层的数据结构实现主要是 <strong>int</strong> 和 <strong>SDS</strong>（简单动态字符串）。</p><ul><li><p>SDS 和我们认识的 C 字符串不太一样，之所以没有使用 C 语言的字符串表示，因为 SDS 相比于 C 的原生字符串：</p></li><li><p>SDS 不仅可以保存文本数据，还可以保存二进制数据。因为 SDS 使用 len 属性的值而不是空字符来判断字符串是否结束，并且 SDS 的所有 API 都会以处理二进制的方式来处理 SDS 存放在 buf[] 数组里的数据。所以 SDS 不光能存放文本数据，而且能保存图片、音频、视频、压缩文件这样的二进制数据。</p></li><li><p>SDS 获取字符串长度的时间复杂度是 O(1)。因为 C 语言的字符串并不记录自身长度，所以获取长度的复杂度为 O(n)；而 SDS 结构里用 len 属性记录了字符串长度，所以复杂度为 O(1)。</p></li><li><p>Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出。因为 SDS 在拼接字符串之前会检查 SDS 空间是否满足要求，如果空间不够会自动扩容，所以不会导致缓冲区溢出的问题。 字符串对象的内部编码（encoding）有 3 种 ：int、raw和 embstr。</p></li></ul><h3 id="使用场景" tabindex="-1"><a class="header-anchor" href="#使用场景"><span>使用场景</span></a></h3><ol><li><strong>缓存对象</strong> - 直接缓存整个对象的 JSON，命令例子： SET user:1 &#39;{&quot;name&quot;:&quot;xiaolin&quot;, &quot;age&quot;:18}&#39;。 - 采用将 key 进行分离为 user:ID:属性，采用 MSET 存储，用 MGET 获取各属性值，命令例子： MSET user:1:name xiaolin user:1:age 18 user:2:name xiaomei user:2:age 20。</li><li><strong>分布式锁</strong> SET 命令有个 NX 参数可以实现「key不存在才插入」，可以用它来实现分布式锁： <ul><li>如果 key 不存在，则显示插入成功，可以用来表示加锁成功；</li><li>如果 key 存在，则会显示插入失败，可以用来表示加锁失败。</li></ul></li></ol><h2 id="list-列表" tabindex="-1"><a class="header-anchor" href="#list-列表"><span>List（列表）</span></a></h2><h3 id="内部实现-1" tabindex="-1"><a class="header-anchor" href="#内部实现-1"><span>内部实现</span></a></h3><p>List 数据类型底层数据结构由 quicklist 实现</p><h3 id="使用场景-1" tabindex="-1"><a class="header-anchor" href="#使用场景-1"><span>使用场景</span></a></h3><ol><li>消息队列 消息队列在存取消息时，必须要满足三个需求，分别是消息保序、处理重复的消息和保证消息可靠性。 Redis 的 List 和 Stream 两种数据类型，就可以满足消息队列的这三个需求。我们先来了解下基于 List 的消息队列实现方法，后面在介绍 Stream 数据类型时候，在详细说说 Stream。</li></ol><h2 id="hash-哈希" tabindex="-1"><a class="header-anchor" href="#hash-哈希"><span>Hash（哈希）</span></a></h2><h3 id="内部实现-2" tabindex="-1"><a class="header-anchor" href="#内部实现-2"><span>内部实现</span></a></h3><p>Hash 类型的底层数据结构是由 listpack 或哈希表实现的： 如果哈希类型元素个数小于 512 个（默认值，可由 hash-max-ziplist-entries 配置），所有值小于 64 字节（默认值，可由 hash-max-ziplist-value 配置）的话，Redis 会使用listpack作为 Hash 类型的底层数据结构； 如果哈希类型元素不满足上面条件，Redis 会使用哈希表作为 Hash 类型的 底层数据结构。</p><h3 id="使用场景-2" tabindex="-1"><a class="header-anchor" href="#使用场景-2"><span>使用场景</span></a></h3><ol><li>缓存对象 Hash 类型的 （key，field， value） 的结构与对象的（对象id， 属性， 值）的结构相似，也可以用来存储对象。</li><li>购物车 以用户 id 为 key，商品 id 为 field，商品数量为 value，恰好构成了购物车的3个要素</li></ol><h2 id="set-集合" tabindex="-1"><a class="header-anchor" href="#set-集合"><span>Set（集合）</span></a></h2><h3 id="内部实现-3" tabindex="-1"><a class="header-anchor" href="#内部实现-3"><span>内部实现</span></a></h3><p>Set 类型的底层数据结构是由哈希表或整数集合实现的：</p><ul><li>如果集合中的元素都是整数且元素个数小于 512 （默认值，set-maxintset-entries配置）个，Redis 会使用整数集合作为 Set 类型的底层数据结构；</li><li>如果集合中的元素不满足上面条件，则 Redis 使用哈希表作为 Set 类型的底层数据结构。</li></ul><h3 id="使用场景-3" tabindex="-1"><a class="header-anchor" href="#使用场景-3"><span>使用场景</span></a></h3><p>集合的主要几个特性，无序、不可重复、支持并交差等操作。</p><ol><li>点赞 Set 类型可以保证一个用户只能点一个赞。</li><li>共同关注 Set 类型支持交集运算，所以可以用来计算共同关注的好友、公众号等。</li><li>抽奖活动 存储某活动中中奖的用户名 ，Set 类型因为有去重功能，可以保证同一个用户不会中奖两次。</li></ol><h2 id="zset-有序集合" tabindex="-1"><a class="header-anchor" href="#zset-有序集合"><span>Zset（有序集合）</span></a></h2><h3 id="内部实现-4" tabindex="-1"><a class="header-anchor" href="#内部实现-4"><span>内部实现</span></a></h3><p>Zset 类型的底层数据结构是由listpack或跳表实现的：</p><ul><li>如果有序集合的元素个数小于 128 个，并且每个元素的值小于 64 字节时，Redis 会使用listpack作为 Zset 类型的底层数据结构；</li><li>如果有序集合的元素不满足上面的条件，Redis 会使用跳表作为 Zset 类型的底层数据结构；</li></ul><h3 id="使用场景-4" tabindex="-1"><a class="header-anchor" href="#使用场景-4"><span>使用场景</span></a></h3><ol><li>排行榜 有序集合比较典型的使用场景就是排行榜。 可以根据想要排序的字段以及辅助字段组成权重分数 然后根据分数进行排序查询。</li></ol><h2 id="bitmap" tabindex="-1"><a class="header-anchor" href="#bitmap"><span>BitMap</span></a></h2><h3 id="内部实现-5" tabindex="-1"><a class="header-anchor" href="#内部实现-5"><span>内部实现</span></a></h3><ul><li>Bitmap 本身是用 String 类型作为底层数据结构实现的一种统计二值状态的数据类型。</li><li>String 类型是会保存为二进制的字节数组，所以，Redis 就把字节数组的每个 bit 位利用起来，用来表示一个元素的二值状态，你可以把 Bitmap 看作是一个 bit 数组。</li></ul><h3 id="使用场景-5" tabindex="-1"><a class="header-anchor" href="#使用场景-5"><span>使用场景</span></a></h3><ol><li>签到统计 在签到打卡的场景中，我们只用记录签到（1）或未签到（0），所以它就是非常典型的二值状态。 签到统计时，每个用户一天的签到用 1 个 bit 位就能表示，一个月（假设是 31 天）的签到情况用 31 个 bit 位就可以，而一年的签到也只需要用 365 个 bit 位，根本不用太复杂的集合类型。</li><li>判断用户登陆态 Bitmap 提供了 GETBIT、SETBIT 操作，通过一个偏移值 offset 对 bit 数组的 offset 位置的 bit 位进行读写操作，需要注意的是 offset 从 0 开始。</li></ol><h2 id="hyperloglog" tabindex="-1"><a class="header-anchor" href="#hyperloglog"><span>HyperLogLog</span></a></h2><p>Redis HyperLogLog 是 Redis 2.8.9 版本新增的数据类型，是一种用于「统计基数」的数据集合类型，基数统计就是指统计一个集合中不重复的元素个数。但要注意，HyperLogLog 是统计规则是基于概率完成的，不是非常准确，标准误算率是 0.81%。 所以，简单来说 HyperLogLog 提供不精确的去重计数。</p><h3 id="内部实现-6" tabindex="-1"><a class="header-anchor" href="#内部实现-6"><span>内部实现</span></a></h3><pre><code>不会\n</code></pre><h3 id="使用场景-6" tabindex="-1"><a class="header-anchor" href="#使用场景-6"><span>使用场景</span></a></h3><ol><li>百万级网页 UV 计数 Redis HyperLogLog 优势在于只需要花费 12 KB 内存，就可以计算接近 2^64 个元素的基数，和元素越多就越耗费内存的 Set 和 Hash 类型相比，HyperLogLog 就非常节省空间。</li></ol><h2 id="geo" tabindex="-1"><a class="header-anchor" href="#geo"><span>GEO</span></a></h2><p>Redis GEO 是 Redis 3.2 版本新增的数据类型，主要用于存储地理位置信息，并对存储的信息进行操作。</p><h3 id="内部实现-7" tabindex="-1"><a class="header-anchor" href="#内部实现-7"><span>内部实现</span></a></h3><pre><code>GEO 本身并没有设计新的底层数据结构，而是直接使用了 Sorted Set 集合类型。\n</code></pre><h3 id="使用场景-7" tabindex="-1"><a class="header-anchor" href="#使用场景-7"><span>使用场景</span></a></h3><h2 id="stream" tabindex="-1"><a class="header-anchor" href="#stream"><span>Stream</span></a></h2><p>Redis Stream 是 Redis 5.0 版本新增加的数据类型，Redis 专门为消息队列设计的数据类型。</p><h3 id="使用场景-8" tabindex="-1"><a class="header-anchor" href="#使用场景-8"><span>使用场景</span></a></h3><ol><li>消息队列 <ul><li>生产者通过 XADD 命令插入一条消息：插入成功后会返回全局唯一的 ID</li><li>消费者通过 XREAD 命令从消息队列中读取消息时，可以指定一个消息 ID，并从这个消息 ID 的下一条消息开始进行读取（注意是输入消息 ID 的下一条信息开始读取，不是查询输入ID的消息）。</li><li>如果想要实现阻塞读（当没有数据时，阻塞住），可以调用 XRAED 时设定 BLOCK 配置项，实现类似于 BRPOP 的阻塞读取操作。</li><li>Stream 可以以使用 XGROUP 创建消费组，创建消费组之后，Stream 可以使用 XREADGROUP 命令让消费组内的消费者读取消息。</li><li>消息队列中的消息一旦被消费组里的一个消费者读取了，就不能再被该消费组内的其他消费者读取了，即同一个消费组里的消费者不能消费同一条消息。但是，不同消费组的消费者可以消费同一条消息（但是有前提条件，创建消息组的时候，不同消费组指定了相同位置开始读取消息）。</li><li>如果消费者没有成功处理消息，它就不会给 Streams 发送 XACK 命令，消息仍然会留存。此时，消费者可以在重启后，用 XPENDING 命令查看已读取、但尚未确认处理完成的消息。</li></ul></li></ol>',49),n={},r=(0,i(6262).A)(n,[["render",function(e,l){return(0,a.uX)(),(0,a.CE)("div",null,[t,(0,a.Q3)(" more "),s])}]]),h=JSON.parse('{"path":"/program/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF.html","title":"Redis数据结构及使用场景","lang":"zh-CN","frontmatter":{"totail":null,"icon":"book","date":"2023-10-01T00:00:00.000Z","category":["编程"],"tag":["Redis"],"head":[["meta",{"property":"og:url","content":"https://github.com/DUDU-dudu-DUDU/xwblog/xwblog/program/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF.html"}],["meta",{"property":"og:site_name","content":"小吴 Blog"}],["meta",{"property":"og:title","content":"Redis数据结构及使用场景"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-12-04T09:38:58.000Z"}],["meta",{"property":"article:author","content":"xiaowu"}],["meta",{"property":"article:tag","content":"Redis"}],["meta",{"property":"article:published_time","content":"2023-10-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-12-04T09:38:58.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis数据结构及使用场景\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-10-01T00:00:00.000Z\\",\\"dateModified\\":\\"2024-12-04T09:38:58.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"xiaowu\\",\\"url\\":\\"https://dudu-dudu-dudu.github.io/xwblog/zh/\\"}]}"]]},"headers":[{"level":2,"title":"String（字符串）","slug":"string-字符串","link":"#string-字符串","children":[{"level":3,"title":"内部实现：","slug":"内部实现","link":"#内部实现","children":[]},{"level":3,"title":"使用场景","slug":"使用场景","link":"#使用场景","children":[]}]},{"level":2,"title":"List（列表）","slug":"list-列表","link":"#list-列表","children":[{"level":3,"title":"内部实现","slug":"内部实现-1","link":"#内部实现-1","children":[]},{"level":3,"title":"使用场景","slug":"使用场景-1","link":"#使用场景-1","children":[]}]},{"level":2,"title":"Hash（哈希）","slug":"hash-哈希","link":"#hash-哈希","children":[{"level":3,"title":"内部实现","slug":"内部实现-2","link":"#内部实现-2","children":[]},{"level":3,"title":"使用场景","slug":"使用场景-2","link":"#使用场景-2","children":[]}]},{"level":2,"title":"Set（集合）","slug":"set-集合","link":"#set-集合","children":[{"level":3,"title":"内部实现","slug":"内部实现-3","link":"#内部实现-3","children":[]},{"level":3,"title":"使用场景","slug":"使用场景-3","link":"#使用场景-3","children":[]}]},{"level":2,"title":"Zset（有序集合）","slug":"zset-有序集合","link":"#zset-有序集合","children":[{"level":3,"title":"内部实现","slug":"内部实现-4","link":"#内部实现-4","children":[]},{"level":3,"title":"使用场景","slug":"使用场景-4","link":"#使用场景-4","children":[]}]},{"level":2,"title":"BitMap","slug":"bitmap","link":"#bitmap","children":[{"level":3,"title":"内部实现","slug":"内部实现-5","link":"#内部实现-5","children":[]},{"level":3,"title":"使用场景","slug":"使用场景-5","link":"#使用场景-5","children":[]}]},{"level":2,"title":"HyperLogLog","slug":"hyperloglog","link":"#hyperloglog","children":[{"level":3,"title":"内部实现","slug":"内部实现-6","link":"#内部实现-6","children":[]},{"level":3,"title":"使用场景","slug":"使用场景-6","link":"#使用场景-6","children":[]}]},{"level":2,"title":"GEO","slug":"geo","link":"#geo","children":[{"level":3,"title":"内部实现","slug":"内部实现-7","link":"#内部实现-7","children":[]},{"level":3,"title":"使用场景","slug":"使用场景-7","link":"#使用场景-7","children":[]}]},{"level":2,"title":"Stream","slug":"stream","link":"#stream","children":[{"level":3,"title":"使用场景","slug":"使用场景-8","link":"#使用场景-8","children":[]}]}],"git":{"createdTime":1732439163000,"updatedTime":1733305138000,"contributors":[{"name":"DJ033016","email":"wujianbo@djbx.com","commits":1},{"name":"DUDU","email":"930824238@qq.com","commits":1}]},"readingTime":{"minutes":7.33,"words":2198},"filePathRelative":"program/redis/Redis数据结构及使用场景.md","localizedDate":"2023年10月1日","excerpt":"\\n"}')}}]);